#pragma once
#include "framerate.h"
struct Actor;
struct InitChainEntry;
struct Color_RGBA8;
struct Vec3f;
struct Vec3s;
struct Input;

void Actor_ProcessInitChain(Actor* actor, InitChainEntry* initChain);
void Color_RGBA8_Copy(Color_RGBA8* dst, Color_RGBA8* src);
void Lib_MemSet(u8* dest, size_t size, u8 val);
void Math_ApproachF(f32* pValue, f32 target, f32 fraction, const Step& step);
void Math_ApproachS(s16* pValue, s16 target, s16 scale, const Step& step);
void Math_ApproachS(Rotation* pValue, s16 target, s16 scale, const FStep& step);
void Math_ApproachZeroF(f32* pValue, f32 fraction, const Step& step);
s32 Math_AsymStepToF(f32* pValue, f32 target, const Step& incrStep, const Step& decrStep);
f32 Math_CosS(s16 angle);
s32 Math_ScaledStepToS(s16* pValue, s16 target, const Step& step);
s32 Math_ScaledStepToS(Rotation* pValue, s16 target, const FStep& step);
f32 Math_SinS(s16 angle);
f32 Math_SmoothStepToDegF(f32* pValue, f32 target, f32 fraction, const Step& step, const Step& minStep);
f32 Math_SmoothStepToF(f32* pValue, f32 target, f32 fraction, const Step& step, const Step& minStep);
f32 Math_SmoothStepToF(Rotation* pValue, f32 target, f32 fraction, const FStep& step, const FStep& minStep);
s16 Math_SmoothStepToS(s16* pValue, s16 target, s16 scale, const Step& step, const Step& minStep);
s16 Math_SmoothStepToS(Rotation* pValue, s16 target, s16 scale, const FStep& step, const FStep& minStep);
s32 Math_StepToAngleS(s16* pValue, s16 target, const Step& step);
s32 Math_StepToAngleS(Rotation* pValue, s16 target, const FStep& step);
s32 Math_StepToF(f32* pValue, f32 target, const Step& step);
s32 Math_StepRotationToF(f32* pValue, f32 target, const Step& step);
f32 Math_AngleDiffF(f32 a, f32 b);
f32 Math_NormalizeAngleF(f32 angle);
f32 Math_AngleF(Vec2f v);
s32 Math_StepToS(s16* pValue, s16 target, const Step& step);
s32 Math_StepToS(Rotation* pValue, s16 target, const FStep& step);
s32 Math_StepUntilAngleS(s16* pValue, s16 limit, const Step& step);
s32 Math_StepUntilF(f32* pValue, f32 limit, const Step& step);
s32 Math_StepUntilS(s16* pValue, s16 limit, const Step& step);
s32 Math_StepUntilS(Rotation* pValue, s16 limit, const FStep& step);
void Math_Vec3f_Copy(Vec3f* dest, Vec3f* src);
void Math_Vec3f_Diff(Vec3f* a, Vec3f* b, Vec3f* dest);
f32 Math_Vec3f_DistXYZ(Vec3f* a, Vec3f* b);
f32 Math_Vec3f_DistXYZAndStoreDiff(Vec3f* a, Vec3f* b, Vec3f* dest);
f32 Math_Vec3f_DistXZ(Vec3f* a, Vec3f* b);
s16 Math_Vec3f_Pitch(Vec3f* a, Vec3f* b);
void Math_Vec3f_Scale(Vec3f* vec, f32 scaleF);
void Math_Vec3f_Sum(Vec3f* a, Vec3f* b, Vec3f* dest);
s16 Math_Vec3f_Yaw(Vec3f* a, Vec3f* b);
void Math_Vec3s_DiffToVec3f(Vec3f* dest, Vec3s* a, Vec3s* b);
void Math_Vec3s_ToVec3f(Vec3f* dest, Vec3s* src);
s16 Rand_S16Offset(s16 base, s16 range);
void func_80077D10(f32* arg0, s16* arg1, Input* input);
void Common_PlaySfx(u16 sfxId);
void Common_PlaySfx2(u16 sfxId);
void Common_PlaySfxAtPos(Vec3f* arg0, u16 sfxId);
